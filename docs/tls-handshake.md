---
id: tls-handshake
title: TLS Handshake
description: 'the handshake of TLS'
---
> Copyright: the following content is totally copy from the [TECHSCHOOL](https://dev.to/techschoolguru/a-complete-overview-of-ssl-tls-and-its-cryptographic-system-36pd).

OK, so now with all the knowledge we’ve gained so far, let’s take a closer look at how they’re used in the TLS handshake protocol.
## Full handshake
### client hello
![client-hello](/docs/assets/Security/client-hello.png)
The TLS 1.3 full handshake starts with a hello message that the client sends to the server. Actually this message contains a lot of things, but here I just list some important information:
1. First, a list of protocol version that client supports.
2. Then a list of supported AEAD symmetric cipher suites. In this case, there are 2 options: AES-256-GCM or CHACHA20-POLY1305
3. After that, there’s a list of supported key exchange groups. For example, this client supports both Finite field Diffie-Hellman Ephemeral and Elliptic-Curve Diffie-Hellman Ephemeral.
4. That’s why client also shares its 2 public keys, 1 for Diffie-Hellman, and the other for Elliptic-Curve Diffie-Hellman. This way, the server will be able to compute the shared secret key no mater what algorithm it chooses.
5. The last field client sends in this message is a list of signature algorithms it supports. This is for server to choose which algorithm it should use to sign the whole handshake. We will see how it works in a bit.

### server hello
![server-hello](/docs/assets/Security/server-hello.png)
After receiving the client hello message, the server also sends back its hello message,which contains:
- The selected protocol version TLS 1.3
- The selected cipher suites: AES-256-GCM
- The selected key exchange method: Diffie-Hellman Ephemeral
- And the server’s public key for that chosen method.
- The next field is a request for the client’s certificate, which is optional and will only be sent if the server wants to authenticate the client by its certificate.
- Normally on a HTTPS website, only the server side needs to send its certificate to the client. And that is sent in the next field of this message.

### authentication messages
![authentication-messages](/docs/assets/Security/authentication-messages.png)
- The next field is certificate verify, which is, in fact, the signature of the entire handshake up to this point. Here’s how it is generated: The whole data from the beginning of the handshake up to the certificate request is called a handshake context. We concatenate this context with the server’s certificate, hash it, and sign the hash value with the server’s private key using 1 of the signature algorithms that the client supports.
- In a similar fashion, the server finish is generated by concatenating the handshake context, the certificate, and the certificate verify, hash it, and put the hash value through the MAC algorithm of the chosen cipher suite. The result is the MAC of the entire handshake.

Here the server certificate, certificate verify, and server finish are called authentication messages, because they are used to authenticate the server. With the signature and MAC of the entire handshake, TLS 1.3 is safe against several types of man-in-the-middle Downgrade attacks.

### client finish
![client-finish](/docs/assets/Security/client-finish.png)
Now after the client receives the hello message from server, it will validate the server’s certificate with the root authority, and check the signature and MAC of the entire handshake to make sure it’s not been tampered with.
If everything is good then the client sends its finish message with the MAC of the entire handshake up to this point, and optionally the client’s certificate and certificate verify in case the server has requested.
And that’s the whole flow of the full TLS handshake.

## Abbreviated handshake with PSK resumption
To improve the performance, the client and server don’t always go through this full handshake. Sometimes, they perform abbreviated handshake by using preshared key resumption.
The idea is: after the previous handshake, the client and server already know each other, so they don’t need to authenticate again.
So the server may send one or multiple session tickets to the client, which can be used as the pre-shared key (PSK) identity in the next handshake. It goes with a ticket lifetime as well as some other information.
![PSK-resumption](/docs/assets/Security/PSK-resumption.png)
Now in the next handshake, the client will send a simple hello message, which contains:
- A list of PSK identities (or tickets) obtained from the previous handshake
- A PSK key exchange mode, which can be either PSK only, or PSK with Diffie-Hellman.
- If the PSK with Diffie-Hellman mode is used, then the client also needs to share its Diffie-Hellman public key. This will provide perfect forward secrecy, as well as allow the server to fallback to full handshake if needed.

When the server receives this client hello message, it sends back its hello with:
- The selected pre-shared key identity
- The optional Diffie-Hellman public key of the server
- And the server Finish just like in the full handshake.
Finally the client sends back its Finish, and that’s the end of the PSK resumption.
As you can see, there’s no certificate authentication between client and server in this abbreviated handshake.
This also opens up an opportunity for zero round-trip time (0-RTT) data, which means, the client doesn’t need to wait for the handshake to complete to send its first application data to the server.

## 0-RTT handshake
![rrt-handshake](/docs/assets/Security/rrt-handshake.png)
In 0-RTT, client sends the application data together with the client hello message. This data is encrypted using the key derived from the first PSK in the ticket list.
And it also adds 1 more field: early data indication to tell the server that there’s early application data being sent along.
If the server accepts this 0-RTT request, it will sends back the server hello just like in the normal PSK resumption, and optionally some application data as well.
The client will finish with a message containing the MAC, and an end-of-early-data indicator. That’s how 0 round-trip time works in TLS 1.3.
Its pros is reduce the latency by 1 round trip time. But the cons is openning up a potential threat of replay attack. Which means, the hacker can just copy and send the same encrypted 0-RTT request to the server multiple times. To avoid this, the server application must be implemented in a way that’s resilient to duplicate requests.

## TLS 1.3 vs TLS 1.2
Now before we finish, let’s do a quick comparison of TLS 1.3 and TLS 1.2 to see what’s new!
![tls-new-version](/docs/assets/Security/tls-new-version.png)

1. TLS 1.3 has safer key exchange mechanisms, where the vulnerable RSA and other static key exchange methods are removed, leaving only ephemeral Diffie-Hellman or Elliptic-Curve Diffie-Hellman remain, therefore achieved perfect forward secrecy.
1. TLS 1.3 handshake is at least 1 round-trip faster than TLS 1.2.
1. Symmetric encryption in TLS 1.3 is more secure because AEAD cipher suite is mandatory, and it also removes some weak algorithms from the list such as Block Cipher Mode (CBC), RC4, or Triple DES.
1. The cipher suite in TLS 1.3 is also simpler, since it only contains the AEAD algorithm and a hash algorithm. The key exchange and signature algorithms are moved to separate fields. While in TLS 1.2, they’re merged into the cipher suite. This makes the number of recommended cipher suites become too big, 37 options in TLS 1.2 if i remember correctly. While in TLS 1.3, there are only 5.
1. Next, TLS 1.3 also give us stronger signature, since it signs the entire handshake, not just cover some part of it as in TLS 1.2.
1. Last but not least, Elliptic-curve cryptography gets a significant attention in TLS 1.3, with some better curves algorithm added, such as Edward-curve digital signature algorithm, which is faster without sacrificing security.

And that’s everything I want to share with you in this article. Thanks for reading, and I’ll catch you guys in the next one!
(window.webpackJsonp=window.webpackJsonp||[]).push([[369],{1181:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=o.a.createContext({}),d=function(e){var t=o.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=d(e.components);return o.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,r=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=d(n),p=a,m=u["".concat(r,".").concat(p)]||u[p]||b[p]||i;return n?o.a.createElement(m,l(l({ref:t},s),{},{components:n})):o.a.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=p;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var s=2;s<i;s++)r[s]=n[s];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},478:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(4),o=n(10),i=(n(0),n(1181)),r={id:"native-modules-ios",title:"iOS Native Modules"},l={unversionedId:"native-modules-ios",id:"native-modules-ios",isDocsHomePage:!1,title:"iOS Native Modules",description:"Welcome to Native Modules for iOS. Please start by reading the Native Modules Intro for an intro to what native modules are.",source:"@site/../docs/native-modules-ios.md",slug:"/native-modules-ios",permalink:"/docs/next/native-modules-ios",editUrl:"https://github.com/facebook/react-native-website/blob/master/website/../docs/native-modules-ios.md",version:"current",lastUpdatedAt:1619935100,formattedLastUpdatedAt:"5/2/2021",sidebar:"docs",previous:{title:"Android Native Modules",permalink:"/docs/next/native-modules-android"},next:{title:"Native Modules NPM Package Setup",permalink:"/docs/next/native-modules-setup"}},c=[{value:"Create a Calendar Native Module",id:"create-a-calendar-native-module",children:[{value:"Setup",id:"setup",children:[]},{value:"Create Custom Native Module Files",id:"create-custom-native-module-files",children:[]},{value:"Module Name",id:"module-name",children:[]},{value:"Export a Native Method to JavaScript",id:"export-a-native-method-to-javascript",children:[]},{value:"Synchronous Methods",id:"synchronous-methods",children:[]},{value:"Test What You Have Built",id:"test-what-you-have-built",children:[]},{value:"Building as You Iterate",id:"building-as-you-iterate",children:[]},{value:"Recap\u2728",id:"recap",children:[]}]},{value:"Beyond a Calendar Native Module",id:"beyond-a-calendar-native-module",children:[{value:"Better Native Module Export",id:"better-native-module-export",children:[]},{value:"Argument Types",id:"argument-types",children:[]},{value:"Exporting Constants",id:"exporting-constants",children:[]},{value:"Callbacks",id:"callbacks",children:[]},{value:"Promises",id:"promises",children:[]},{value:"Sending Events to JavaScript",id:"sending-events-to-javascript",children:[]},{value:"Threading",id:"threading",children:[]},{value:"Dependency Injection",id:"dependency-injection",children:[]},{value:"Exporting Swift",id:"exporting-swift",children:[]},{value:"Reserved Method Names",id:"reserved-method-names",children:[]}]}],s={toc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Welcome to Native Modules for iOS. Please start by reading the ",Object(i.b)("a",{parentName:"p",href:"native-modules-intro"},"Native Modules Intro")," for an intro to what native modules are."),Object(i.b)("h2",{id:"create-a-calendar-native-module"},"Create a Calendar Native Module"),Object(i.b)("p",null,"In the following guide you will create a native module, ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule"),", that will allow you to access Apple's calendar APIs from JavaScript. By the end you will be able to call ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule.createCalendarEvent('Dinner Party', 'My House');")," from JavaScript, invoking a native method that creates a calendar event."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"The React Native team is currently working on a re-architecture of the Native Module system. This new system is called TurboModules, and it will help facilitate more efficient type-safe communication between JavaScript and native, without relying on the React Native bridge. It will also enable new extensions that weren't possible with the legacy Native Module system. You can read more about it ",Object(i.b)("a",{parentName:"p",href:"https://github.com/react-native-community/discussions-and-proposals/issues/40"},"here"),". Throughout these docs we have added notes around parts of Native Modules that will change in the TurboModules release and how you can best prepare for a smooth upgrade to TurboModules.")),Object(i.b)("h3",{id:"setup"},"Setup"),Object(i.b)("p",null,"To get started, open up the iOS project within your React Native application in Xcode. You can find your iOS project here within a React Native app:"),Object(i.b)("figure",null,Object(i.b)("img",{src:"/docs/assets/native-modules-ios-open-project.png",width:"500",alt:"Image of opening up an iOS project within a React Native app inside of xCode."}),Object(i.b)("figcaption",null,"Image of where you can find your iOS project")),Object(i.b)("p",null,"We recommend using Xcode to write your native code. Xcode is built for iOS development, and using it will help you to quickly resolve smaller errors like code syntax."),Object(i.b)("h3",{id:"create-custom-native-module-files"},"Create Custom Native Module Files"),Object(i.b)("p",null,"The first step is to create our main custom native module header and implementation files. Create a new file called ",Object(i.b)("inlineCode",{parentName:"p"},"RCTCalendarModule.h")),Object(i.b)("figure",null,Object(i.b)("img",{src:"/docs/assets/native-modules-ios-add-class.png",width:"500",alt:"Image of creating a class called  RCTCalendarModule.h."}),Object(i.b)("figcaption",null,"Image of creating a custom native module file within the same folder as AppDelegate")),Object(i.b)("p",null,"and add the following to it:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"//  RCTCalendarModule.h\n#import <React/RCTBridgeModule.h>\n@interface RCTCalendarModule : NSObject <RCTBridgeModule>\n@end\n\n")),Object(i.b)("p",null,"You can use any name that fits the native module you are building. Name the class ",Object(i.b)("inlineCode",{parentName:"p"},"RCTCalendarModule")," since you are creating a calendar native module. Since ObjC does not have language-level support for namespaces like Java or C++, convention is to prepend the class name with a substring. This could be an abbreviation of your application name or your infra name. RCT, in this example, refers to React."),Object(i.b)("p",null,"As you can see below, the CalendarModule class implements the ",Object(i.b)("inlineCode",{parentName:"p"},"RCTBridgeModule")," protocol. A native module is an Objective-C class that implements the ",Object(i.b)("inlineCode",{parentName:"p"},"RCTBridgeModule")," protocol."),Object(i.b)("p",null,"Next up, let\u2019s start implementing the native module. Create the corresponding implementation file, ",Object(i.b)("inlineCode",{parentName:"p"},"RCTCalendarModule.m"),", in the same folder and include the following content:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'// RCTCalendarModule.m\n#import "RCTCalendarModule.h"\n\n@implementation RCTCalendarModule\n\n// To export a module named RCTCalendarModule\nRCT_EXPORT_MODULE();\n\n@end\n\n')),Object(i.b)("h3",{id:"module-name"},"Module Name"),Object(i.b)("p",null,"For now, your ",Object(i.b)("inlineCode",{parentName:"p"},"RCTCalendarModule.m")," native module only includes a ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro, which exports and registers the native module class with React Native. The ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," macro also takes an optional argument that specifies the name that the module will be accessible as in your JavaScript code."),Object(i.b)("p",null,"This argument is not a string literal. In the example below ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE(CalendarModuleFoo)")," is passed, not ",Object(i.b)("inlineCode",{parentName:"p"},'RCT_EXPORT_MODULE("CalendarModuleFoo")'),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"// To export a module named CalendarModuleFoo\nRCT_EXPORT_MODULE(CalendarModuleFoo);\n")),Object(i.b)("p",null,"The native module can then be accessed in JS like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const { CalendarModuleFoo } = ReactNative.NativeModules;\n")),Object(i.b)("p",null,'If you do not specify a name, the JavaScript module name will match the Objective-C class name, with any "RCT" or "RK" prefixes removed.'),Object(i.b)("p",null,"Let's follow the example below and call ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_MODULE")," without any arguments. As a result, the module will be exposed to React Native using the name ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule"),", since that is the Objective-C class name, with RCT removed."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"// Without passing in a name this will export the native module name as the Objective-C class name with \u201cRCT\u201d removed\nRCT_EXPORT_MODULE();\n")),Object(i.b)("p",null,"The native module can then be accessed in JS like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const { CalendarModule } = ReactNative.NativeModules;\n")),Object(i.b)("h3",{id:"export-a-native-method-to-javascript"},"Export a Native Method to JavaScript"),Object(i.b)("p",null,"React Native will not expose any methods in a native module to JavaScript unless explicitly told to. This can be done using the ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_METHOD")," macro. Methods written in the ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_METHOD")," macro are asynchronous and the return type is therefore always void. In order to pass a result from a ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_METHOD")," method to JavaScript you can use callbacks or emit events (covered below). Let\u2019s go ahead and set up a native method for our ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule")," native module using the ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_METHOD")," macro. Call it ",Object(i.b)("inlineCode",{parentName:"p"},"createCalendarEvent()")," and for now have it take in name and location arguments as strings. Argument type options will be covered shortly."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location)\n{\n}\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Please note that the ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_METHOD")," macro will not be necessary with TurboModules unless your method relies on RCT argument conversion (see argument types below). Ultimately, React Native will remove ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_MACRO,")," so we discourage people from using ",Object(i.b)("inlineCode",{parentName:"p"},"RCTConvert"),". Instead, you can do the argument conversion within the method body.")),Object(i.b)("p",null,"Before you build out the ",Object(i.b)("inlineCode",{parentName:"p"},"createCalendarEvent()")," method\u2019s functionality, add a console log in the method so you can confirm it has been invoked from JavaScript in your React Native application. Use the ",Object(i.b)("inlineCode",{parentName:"p"},"RCTLog")," APIs from React. Let\u2019s import that header at the top of your file and then add the log call."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'#import <React/RCTLog.h>\nRCT_EXPORT_METHOD(createCalendarEvent:(NSString *)name location:(NSString *)location)\n{\n RCTLogInfo(@"Pretending to create an event %@ at %@", name, location);\n}\n')),Object(i.b)("h3",{id:"synchronous-methods"},"Synchronous Methods"),Object(i.b)("p",null,"You can use the ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD")," to create a synchronous native method."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD(getName)\n{\nreturn [[UIDevice currentDevice] name];\n}\n")),Object(i.b)("p",null,"The return type of this method must be of object type (id) and should be serializable to JSON. This means that the hook can only return nil or JSON values (e.g. NSNumber, NSString, NSArray, NSDictionary)."),Object(i.b)("p",null,"At the moment, we do not recommend using synchronous methods, since calling methods synchronously can have strong performance penalties and introduce threading-related bugs to your native modules. Additionally, please note that if you choose to use ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXPORT_BLOCKING_SYNCHRONOUS_METHOD"),", your app can no longer use the Google Chrome debugger. This is because synchronous methods require the JS VM to share memory with the app. For the Google Chrome debugger, React Native runs inside the JS VM in Google Chrome, and communicates asynchronously with the mobile devices via WebSockets."),Object(i.b)("h3",{id:"test-what-you-have-built"},"Test What You Have Built"),Object(i.b)("p",null,"At this point you have set up the basic scaffolding for your native module in iOS. Test that out by accessing the native module and invoking it\u2019s exported method in JavaScript."),Object(i.b)("p",null,"Find a place in your application where you would like to add a call to the native module\u2019s ",Object(i.b)("inlineCode",{parentName:"p"},"createCalendarEvent()")," method. Below is an example of a component, ",Object(i.b)("inlineCode",{parentName:"p"},"NewModuleButton")," you can add in your app. You can invoke the native module inside ",Object(i.b)("inlineCode",{parentName:"p"},"NewModuleButton"),"'s ",Object(i.b)("inlineCode",{parentName:"p"},"onPress()")," function."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport { NativeModules, Button } from 'react-native';\n\nconst NewModuleButton = () => {\n  const onPress = () => {\n    console.log('We will invoke the native module here!');\n  };\n\n  return (\n    <Button\n      title=\"Click to invoke your native module!\"\n      color=\"#841584\"\n      onPress={onPress}\n    />\n  );\n};\n\nexport default NewModuleButton;\n")),Object(i.b)("p",null,"In order to access your native module from JavaScript you need to first import ",Object(i.b)("inlineCode",{parentName:"p"},"NativeNodules")," from React Native:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"import { NativeModules } from 'react-native';\n")),Object(i.b)("p",null,"You can then access the ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule")," native module off of ",Object(i.b)("inlineCode",{parentName:"p"},"NativeModules"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const { CalendarModule } = NativeModules;\n")),Object(i.b)("p",null,"Now that you have the CalendarModule native module available, you can invoke your native method ",Object(i.b)("inlineCode",{parentName:"p"},"createCalendarEvent()"),". Below it is added to the ",Object(i.b)("inlineCode",{parentName:"p"},"onPress()")," method in ",Object(i.b)("inlineCode",{parentName:"p"},"NewModuleButton"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const onPress = () => {\n  CalendarModule.createCalendarEvent('testName', 'testLocation');\n};\n")),Object(i.b)("p",null,"The final step is to rebuild the React Native app so that you can have the latest native code (with your new native module!) available. In your command line, where the react native application is located, run the following :"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-shell"},"npx react-native run-ios\n")),Object(i.b)("h3",{id:"building-as-you-iterate"},"Building as You Iterate"),Object(i.b)("p",null,"As you work through these guides and iterate on your native module, you will need to do a native rebuild of your application to access your most recent changes from JavaScript. This is because the code that you are writing sits within the native part of your application. While React Native\u2019s metro bundler can watch for changes in JavaScript and rebuild JS bundle on the fly for you, it will not do so for native code. So if you want to test your latest native changes you need to rebuild by using the ",Object(i.b)("inlineCode",{parentName:"p"},"npx react-native run-ios")," command."),Object(i.b)("h3",{id:"recap"},"Recap\u2728"),Object(i.b)("p",null,"You should now be able to invoke your ",Object(i.b)("inlineCode",{parentName:"p"},"createCalendarEvent()")," method on your native module in JavaScript. Since you are using ",Object(i.b)("inlineCode",{parentName:"p"},"RCTLog")," in the function, you can confirm your native method is being invoked by ",Object(i.b)("a",{parentName:"p",href:"https://reactnative.dev/docs/debugging#chrome-developer-tools"},"enabling debug mode in your app")," and looking at the JS console in Chrome or the mobile app debugger Flipper. You should see your ",Object(i.b)("inlineCode",{parentName:"p"},'RCTLogInfo(@"Pretending to create an event %@ at %@", name, location);')," message each time you invoke the native module method."),Object(i.b)("figure",null,Object(i.b)("img",{src:"/docs/assets/native-modules-ios-logs.png",width:"1000",alt:"Image of logs."}),Object(i.b)("figcaption",null,"Image of iOS logs in Flipper")),Object(i.b)("p",null,"At this point you have created an iOS native module and invoked a method on it from JavaScript in your React Native application. You can read on to learn more about things like what argument types your native module method takes and how to setup callbacks and promises within your native module."),Object(i.b)("h2",{id:"beyond-a-calendar-native-module"},"Beyond a Calendar Native Module"),Object(i.b)("h3",{id:"better-native-module-export"},"Better Native Module Export"),Object(i.b)("p",null,"Importing your native module by pulling it off of ",Object(i.b)("inlineCode",{parentName:"p"},"NativeModules")," like above is a bit clunky."),Object(i.b)("p",null,"To save consumers of your native module from needing to do that each time they want to access your native module, you can create a JavaScript wrapper for the module. Create a new JavaScript file named NativeCalendarModule.js with the following content:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"/**\n* This exposes the native CalendarModule module as a JS module. This has a\n* function 'createCalendarEvent' which takes the following parameters:\n\n* 1. String name: A string representing the name of the event\n* 2. String location: A string representing the location of the event\n*/\nimport { NativeModules } from 'react-native';\nconst { CalendarModule } = NativeModules;\nexport default CalendarModule;\n")),Object(i.b)("p",null,"This JavaScript file also becomes a good location for you to add any JavaScript side functionality. For example, if you use a type system like TypeScript you can add type annotations for your native module here. While React Native does not yet support Native to JS type safety, with these type annotations, all your JS code will be type safe. These annotations will also make it easier for you to switch to type-safe native modules down the line. Below is an example of adding type safety to the Calendar Module:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"/**\n* This exposes the native CalendarModule module as a JS module. This has a\n* function 'createCalendarEvent' which takes the following parameters:\n*\n* 1. String name: A string representing the name of the event\n* 2. String location: A string representing the location of the event\n*/\nimport { NativeModules } from 'react-native';\nconst { CalendarModule } = NativeModules\ninterface CalendarInterface {\n   createCalendarEvent(name: string, location: string): void;\n}\nexport default CalendarModule as CalendarInterface;\n")),Object(i.b)("p",null,"In your other JavaScript files you can access the native module and invoke its method like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"import NativeCalendarModule from './NativeCalendarModule';\nNativeCalendarModule.createCalendarEvent('foo', 'bar');\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Note this assumes that the place you are importing ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule")," is in the same hierarchy as ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule.js"),". Please update the relative import as necessary.")),Object(i.b)("h3",{id:"argument-types"},"Argument Types"),Object(i.b)("p",null,"When a native module method is invoked in JavaScript, React Native converts the arguments from JS objects to their Objective-C/Swift object analogues. So for example, if your Objective-C Native Module method accepts a NSNumber, in JS you need to call the method with a number. React Native will handle the conversion for you. Below is a list of the argument types supported for native module methods and the JavaScript equivalents they map to."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",{parentName:"tr",align:null},"Objective-C"),Object(i.b)("th",{parentName:"tr",align:null},"JavaScript"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"NSString"),Object(i.b)("td",{parentName:"tr",align:null},"string, ?string")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"BOOL"),Object(i.b)("td",{parentName:"tr",align:null},"boolean")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"NSNumber"),Object(i.b)("td",{parentName:"tr",align:null},"?boolean")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"double"),Object(i.b)("td",{parentName:"tr",align:null},"number")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"NSNumber"),Object(i.b)("td",{parentName:"tr",align:null},"?number")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"NSArray"),Object(i.b)("td",{parentName:"tr",align:null},"Array, ?Array")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"NSDictionary"),Object(i.b)("td",{parentName:"tr",align:null},"Object, ?Object")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"RCTResponseSenderBlock"),Object(i.b)("td",{parentName:"tr",align:null},"Function (success)")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"RCTResponseSenderBlock, RCTResponseErrorBlock"),Object(i.b)("td",{parentName:"tr",align:null},"Function (failure)")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",{parentName:"tr",align:null},"RCTPromiseResolveBlock, RCTPromiseRejectBlock"),Object(i.b)("td",{parentName:"tr",align:null},"Promise")))),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"The following types are currently supported but will not be supported in TurboModules. Please avoid using them."),Object(i.b)("ul",{parentName:"blockquote"},Object(i.b)("li",{parentName:"ul"},"Function (failure) -> RCTResponseErrorBlock"),Object(i.b)("li",{parentName:"ul"},"Number -> NSInteger"),Object(i.b)("li",{parentName:"ul"},"Number -> CGFloat"),Object(i.b)("li",{parentName:"ul"},"Number -> float"))),Object(i.b)("p",null,"For iOS, you can also write native module methods with any argument type that is supported by the ",Object(i.b)("inlineCode",{parentName:"p"},"RCTConvert")," class (see ",Object(i.b)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/master/React/Base/RCTConvert.h"},"RCTConvert")," for details about what is supported). The RCTConvert helper functions all accept a JSON value as input and map it to a native Objective-C type or class."),Object(i.b)("h3",{id:"exporting-constants"},"Exporting Constants"),Object(i.b)("p",null,"A native module can export constants by overriding the native method ",Object(i.b)("inlineCode",{parentName:"p"},"constantsToExport()"),". Below ",Object(i.b)("inlineCode",{parentName:"p"},"constantsToExport()")," is overriden, and returns a Dictionary that contains a default event name property you can access in JavaScript like so:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'- (NSDictionary *)constantsToExport\n{\n return @{ @"DEFAULT_EVENT_NAME": @"New Event" };\n}\n')),Object(i.b)("p",null,"The constant can then be accessed by invoking ",Object(i.b)("inlineCode",{parentName:"p"},"getConstants()")," on the native module in JS like so:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"const { DEFAULT_EVENT_NAME } = CalendarModule.getConstants();\nconsole.log(DEFAULT_EVENT_NAME);\n")),Object(i.b)("p",null,"Technically, it is possible to access constants exported in ",Object(i.b)("inlineCode",{parentName:"p"},"constantsToExport()")," directly off the ",Object(i.b)("inlineCode",{parentName:"p"},"NativeModule")," object. This will no longer be supported with TurboModules, so we encourage the community to switch to the above approach to avoid necessary migration down the line."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Note that the constants are exported only at initialization time, so if you change ",Object(i.b)("inlineCode",{parentName:"p"},"constantsToExport()")," values at runtime it won't affect the JavaScript environment.")),Object(i.b)("p",null,"For iOS, if you override ",Object(i.b)("inlineCode",{parentName:"p"},"constantsToExport()")," then you should also implement ",Object(i.b)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup")," to let React Native know if your module needs to be initialized on the main thread, before any JavaScript code executes. Otherwise you will see a warning that in the future your module may be initialized on a background thread unless you explicitly opt out with ",Object(i.b)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup:"),". If your module does not require access to UIKit, then you should respond to ",Object(i.b)("inlineCode",{parentName:"p"},"+ requiresMainQueueSetup")," with NO."),Object(i.b)("h3",{id:"callbacks"},"Callbacks"),Object(i.b)("p",null,"Native modules also support a unique kind of argument - a callback. Callbacks are used to pass data from Objective-C to JavaScript for asynchronous methods. They can also be used to asynchronously execute JS from the native side."),Object(i.b)("p",null,"For iOS, callbacks are implemented using the type ",Object(i.b)("inlineCode",{parentName:"p"},"RCTResponseSenderBlock"),". Below the callback parameter ",Object(i.b)("inlineCode",{parentName:"p"},"myCallBack")," is added to the ",Object(i.b)("inlineCode",{parentName:"p"},"createCalendarEventMethod()"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title\n                location:(NSString *)location\n                myCallback:(RCTResponseSenderBlock)callback)\n\n")),Object(i.b)("p",null,"You can then invoke the callback in your native function, providing whatever result you want to pass to JavaScript in an array. Note that ",Object(i.b)("inlineCode",{parentName:"p"},"RCTResponseSenderBlock")," accepts only one argument - an array of parameters to pass to the JavaScript callback. Below you will pass back the ID of an event created in an earlier call."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"It is important to highlight that the callback is not invoked immediately after the native function completes\u2014remember the communication is asynchronous.")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title location:(NSString *)location callback: (RCTResponseSenderBlock)callback)\n{\n NSInteger eventId = ...\n callback(@[@(eventId)]);\n\n RCTLogInfo(@"Pretending to create an event %@ at %@", title, location);\n}\n\n')),Object(i.b)("p",null,"This method could then be accessed in JavaScript using the following:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const onSubmit = () => {\n  CalendarModule.createCalendarEvent(\n    'Party',\n    '04-12-2020',\n    (eventId) => {\n      console.log(`Created a new event with id ${eventId}`);\n    }\n  );\n};\n")),Object(i.b)("p",null,"A native module is supposed to invoke its callback only once. It can, however, store the callback and invoke it later. This pattern is often used to wrap iOS APIs that require delegates\u2014 see ",Object(i.b)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/3a11f0536ea65b87dc0f006665f16a87cfa14b5e/React/CoreModules/RCTAlertManager.mm"},Object(i.b)("inlineCode",{parentName:"a"},"RCTAlertManager"))," for an example. If the callback is never invoked, some memory is leaked."),Object(i.b)("p",null,"There are two approaches to error handling with callbacks. The first is to follow Node\u2019s convention and treat the first argument passed to the callback array as an error object."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"RCT_EXPORT_METHOD(createCalendarEventCallback:(NSString *)title location:(NSString *)location callback: (RCTResponseSenderBlock)callback)\n{\n  NSNumber *eventId = [NSNumber numberWithInt:123];\n  callback(@[[NSNull null], eventId]);\n}\n")),Object(i.b)("p",null,"In JavaScript, you can then check the first argument to see if an error was passed through:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const onPress = () => {\n  CalendarModule.createCalendarEventCallback(\n    'testName',\n    'testLocation',\n    (error, eventId) => {\n      if (error) {\n        console.error(`Error found! ${error}`);\n      }\n      console.log(`event id ${eventId} returned`);\n    }\n  );\n};\n")),Object(i.b)("p",null,"Another option is to use two separate callbacks: onFailure and onSuccess."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"RCT_EXPORT_METHOD(createCalendarEventCallback:(NSString *)title\n                  location:(NSString *)location\n                  errorCallback: (RCTResponseSenderBlock)errorCallback\n                  successCallback: (RCTResponseSenderBlock)successCallback)\n{\n  @try {\n    NSNumber *eventId = [NSNumber numberWithInt:123];\n    successCallback(@[eventId]);\n  }\n\n  @catch ( NSException *e ) {\n    errorCallback(@[e]);\n  }\n}\n")),Object(i.b)("p",null,"Then in JavaScript you can add a separate callback for error and success responses:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const onPress = () => {\n  CalendarModule.createCalendarEventCallback(\n    'testName',\n    'testLocation',\n    (error) => {\n      console.error(`Error found! ${error}`);\n    },\n    (eventId) => {\n      console.log(`event id ${eventId} returned`);\n    }\n  );\n};\n")),Object(i.b)("p",null,"If you want to pass error-like objects to JavaScript, use ",Object(i.b)("inlineCode",{parentName:"p"},"RCTMakeError")," from ",Object(i.b)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/master/React/Base/RCTUtils.h"},Object(i.b)("inlineCode",{parentName:"a"},"RCTUtils.h."))," Right now this only passes an Error-shaped dictionary to JavaScript, but React Native aims to automatically generate real JavaScript Error objects in the future. You can also provide a ",Object(i.b)("inlineCode",{parentName:"p"},"RCTResponseErrorBlock")," argument, which is used for error callbacks and accepts an ",Object(i.b)("inlineCode",{parentName:"p"},"NSError \\* object"),". Please note that this argument type will not be supported with TurboModules."),Object(i.b)("h3",{id:"promises"},"Promises"),Object(i.b)("p",null,"Native modules can also fulfill a promise, which can simplify your JavaScript, especially when using ES2016's ",Object(i.b)("inlineCode",{parentName:"p"},"async/await")," syntax. When the last parameter of a native module method is a ",Object(i.b)("inlineCode",{parentName:"p"},"RCTPromiseResolveBlock")," and ",Object(i.b)("inlineCode",{parentName:"p"},"RCTPromiseRejectBlock"),", its corresponding JS method will return a JS Promise object."),Object(i.b)("p",null,"Refactoring the above code to use a promise instead of callbacks looks like this:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'RCT_EXPORT_METHOD(createCalendarEvent:(NSString *)title\n                 location:(NSString *)location\n                 resolver:(RCTPromiseResolveBlock)resolve\n                 rejecter:(RCTPromiseRejectBlock)reject)\n{\n NSInteger eventId = createCalendarEvent();\n if (eventId) {\n    resolve(@(eventId));\n  } else {\n    reject(@"event_failure", @"no event id returned", nil);\n  }\n}\n\n')),Object(i.b)("p",null,"The JavaScript counterpart of this method returns a Promise. This means you can use the ",Object(i.b)("inlineCode",{parentName:"p"},"await")," keyword within an async function to call it and wait for its result:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-jsx"},"const onSubmit = async () => {\n  try {\n    const eventId = await CalendarModule.createCalendarEvent(\n      'Party',\n      'my house'\n    );\n    console.log(`Created a new event with id ${eventId}`);\n  } catch (e) {\n    console.error(e);\n  }\n};\n")),Object(i.b)("h3",{id:"sending-events-to-javascript"},"Sending Events to JavaScript"),Object(i.b)("p",null,"Native modules can signal events to JavaScript without being invoked directly. For example, you might want to signal to JavaScript a reminder that a calendar event from the native iOS calendar app will occur soon. The preferred way to do this is to subclass ",Object(i.b)("inlineCode",{parentName:"p"},"RCTEventEmitter"),", implement ",Object(i.b)("inlineCode",{parentName:"p"},"supportedEvents")," and call self ",Object(i.b)("inlineCode",{parentName:"p"},"sendEventWithName"),":"),Object(i.b)("p",null,"Update your header class to import ",Object(i.b)("inlineCode",{parentName:"p"},"RCTEventEmitter")," and subclass ",Object(i.b)("inlineCode",{parentName:"p"},"RCTEventEmitter"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"//  CalendarModule.h\n\n#import <React/RCTBridgeModule.h>\n#import <React/RCTEventEmitter.h>\n\n@interface CalendarModule : RCTEventEmitter <RCTBridgeModule>\n@end\n\n")),Object(i.b)("p",null,"JavaScript code can subscribe to these events by creating a new ",Object(i.b)("inlineCode",{parentName:"p"},"NativeEventEmitter")," instance around your module."),Object(i.b)("p",null,"You will receive a warning if you expend resources unnecessarily by emitting an event while there are no listeners. To avoid this, and to optimize your module's workload (e.g. by unsubscribing from upstream notifications or pausing background tasks), you can override ",Object(i.b)("inlineCode",{parentName:"p"},"startObserving")," and ",Object(i.b)("inlineCode",{parentName:"p"},"stopObserving")," in your ",Object(i.b)("inlineCode",{parentName:"p"},"RCTEventEmitter")," subclass."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'@implementation CalendarManager\n{\n  bool hasListeners;\n}\n\n// Will be called when this module\'s first listener is added.\n-(void)startObserving {\n    hasListeners = YES;\n    // Set up any upstream listeners or background tasks as necessary\n}\n\n// Will be called when this module\'s last listener is removed, or on dealloc.\n-(void)stopObserving {\n    hasListeners = NO;\n    // Remove upstream listeners, stop unnecessary background tasks\n}\n\n- (void)calendarEventReminderReceived:(NSNotification *)notification\n{\n  NSString *eventName = notification.userInfo[@"name"];\n  if (hasListeners) { // Only send events if anyone is listening\n    [self sendEventWithName:@"EventReminder" body:@{@"name": eventName}];\n  }\n}\n\n')),Object(i.b)("h3",{id:"threading"},"Threading"),Object(i.b)("p",null,"Unless the native module provides its own method queue, it shouldn't make any assumptions about what thread it's being called on. Currently, if a native module doesn't provide a method queue, React Native will create a separate GCD queue for it and invoke its methods there. Please note that this is an implementation detail and might change. If you want to explicitly provide a method queue for a native module, override the ",Object(i.b)("inlineCode",{parentName:"p"},"(dispatch_queue_t) methodQueue")," method in the native module. For example, if it needs to use a main-thread-only iOS API, it should specify this via:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"- (dispatch_queue_t)methodQueue\n{\n  return dispatch_get_main_queue();\n}\n")),Object(i.b)("p",null,"Similarly, if an operation may take a long time to complete, the native module can specify its own queue to run operations on. Again, currently React Native will provide a separate method queue for your native module, but this is an implementation detail you should not rely on. If you don't provide your own method queue, in the future, your native module's long running operations may end up blocking async calls being executed on other unrelated native modules. The ",Object(i.b)("inlineCode",{parentName:"p"},"RCTAsyncLocalStorage")," module here, for example, creates its own queue so the React queue isn't blocked waiting on potentially slow disk access."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},'- (dispatch_queue_t)methodQueue\n{\n return dispatch_queue_create("com.facebook.React.AsyncLocalStorageQueue", DISPATCH_QUEUE_SERIAL);\n}\n')),Object(i.b)("p",null,"The specified ",Object(i.b)("inlineCode",{parentName:"p"},"methodQueue")," will be shared by all of the methods in your module. If only one of your methods is long-running (or needs to be run on a different queue than the others for some reason), you can use ",Object(i.b)("inlineCode",{parentName:"p"},"dispatch_async")," inside the method to perform that particular method's code on another queue, without affecting the others:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"RCT_EXPORT_METHOD(doSomethingExpensive:(NSString *)param callback:(RCTResponseSenderBlock)callback)\n{\n dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n   // Call long-running code on background thread\n   ...\n   // You can invoke callback from any thread/queue\n   callback(@[...]);\n });\n}\n\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Sharing dispatch queues between modules"),Object(i.b)("p",{parentName:"blockquote"},"The ",Object(i.b)("inlineCode",{parentName:"p"},"methodQueue")," method will be called once when the module is initialized, and then retained by React Native, so there is no need to keep a reference to the queue yourself, unless you wish to make use of it within your module. However, if you wish to share the same queue between multiple modules then you will need to ensure that you retain and return the same queue instance for each of them.")),Object(i.b)("h3",{id:"dependency-injection"},"Dependency Injection"),Object(i.b)("p",null,"React Native will create and initialize any registered native modules automatically. However, you may wish to create and initialize your own module instances to, for example, inject dependencies."),Object(i.b)("p",null,"You can do this by creating a class that implements the ",Object(i.b)("inlineCode",{parentName:"p"},"RCTBridgeDelegate")," Protocol, initializing an ",Object(i.b)("inlineCode",{parentName:"p"},"RCTBridge")," with the delegate as an argument and initialising a ",Object(i.b)("inlineCode",{parentName:"p"},"RCTRootView")," with the initialized bridge."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"id<RCTBridgeDelegate> moduleInitialiser = [[classThatImplementsRCTBridgeDelegate alloc] init];\n\nRCTBridge *bridge = [[RCTBridge alloc] initWithDelegate:moduleInitialiser launchOptions:nil];\n\nRCTRootView *rootView = [[RCTRootView alloc]\n                        initWithBridge:bridge\n                            moduleName:kModuleName\n                     initialProperties:nil];\n")),Object(i.b)("h3",{id:"exporting-swift"},"Exporting Swift"),Object(i.b)("p",null,"Swift doesn't have support for macros, so exposing native modules and their methods to JavaScript inside React Native requires a bit more setup. However, it works relatively the same. Let's say you have the same ",Object(i.b)("inlineCode",{parentName:"p"},"CalendarModule")," but as a Swift class:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-swift"},'// CalendarManager.swift\n\n@objc(CalendarManager)\nclass CalendarManager: NSObject {\n\n @objc(addEvent:location:date:)\n func addEvent(_ name: String, location: String, date: NSNumber) -> Void {\n   // Date is ready to use!\n }\n\n @objc\n func constantsToExport() -> [String: Any]! {\n   return ["someKey": "someValue"]\n }\n\n}\n')),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"It is important to use the ",Object(i.b)("inlineCode",{parentName:"p"},"@objc")," modifiers to ensure the class and functions are exported properly to the Objective-C runtime.")),Object(i.b)("p",null,"Then create a private implementation file that will register the required information with React Native:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"// CalendarManagerBridge.m\n#import <React/RCTBridgeModule.h>\n\n@interface RCT_EXTERN_MODULE(CalendarManager, NSObject)\n\nRCT_EXTERN_METHOD(addEvent:(NSString *)name location:(NSString *)location date:(nonnull NSNumber *)date)\n\n@end\n")),Object(i.b)("p",null,"For those of you new to Swift and Objective-C, whenever you ",Object(i.b)("a",{parentName:"p",href:"https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html"},"mix the two languages in an iOS project"),", you will also need an additional bridging file, known as a bridging header, to expose the Objective-C files to Swift. Xcode will offer to create this header file for you if you add your Swift file to your app through the Xcode ",Object(i.b)("inlineCode",{parentName:"p"},"File>New File")," menu option. You will need to import ",Object(i.b)("inlineCode",{parentName:"p"},"RCTBridgeModule.h")," in this header file."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-objectivec"},"// CalendarManager-Bridging-Header.h\n#import <React/RCTBridgeModule.h>\n")),Object(i.b)("p",null,"You can also use ",Object(i.b)("inlineCode",{parentName:"p"},"RCT_EXTERN_REMAP_MODULE")," and ",Object(i.b)("inlineCode",{parentName:"p"},"_RCT_EXTERN_REMAP_METHOD")," to alter the JavaScript name of the module or methods you are exporting. For more information see ",Object(i.b)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/master/React/Base/RCTBridgeModule.h"},Object(i.b)("inlineCode",{parentName:"a"},"RCTBridgeModule")),"."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"Important when making third party modules: Static libraries with Swift are only supported in Xcode 9 and later. In order for the Xcode project to build when you use Swift in the iOS static library you include in the module, your main app project must contain Swift code and a bridging header itself. If your app project does not contain any Swift code, a workaround can be a single empty .swift file and an empty bridging header.")),Object(i.b)("h3",{id:"reserved-method-names"},"Reserved Method Names"),Object(i.b)("h4",{id:"invalidate"},"invalidate()"),Object(i.b)("p",null,"Native modules can conform to the ",Object(i.b)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/0.62-stable/React/Base/RCTInvalidating.h"},"RCTInvalidating")," protocol on iOS by implementing the ",Object(i.b)("inlineCode",{parentName:"p"},"invalidate()")," method. This method ",Object(i.b)("a",{parentName:"p",href:"https://github.com/facebook/react-native/blob/0.62-stable/ReactCommon/turbomodule/core/platform/ios/RCTTurboModuleManager.mm#L456"},"can be invoked")," when the native bridge is invalidated (ie: on devmode reload). Please use this mechanism as necessary to do the required cleanup for your native module."))}d.isMDXComponent=!0}}]);